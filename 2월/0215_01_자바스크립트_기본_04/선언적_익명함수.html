<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>익명함수 이름없는 함수</title>
</head>
<body>

    <script>
        'use strict'
        //1. 함수를 선언해서 만들고
        //2. 함수를 호출해야만 실행이 된다.
        //3. 선언적 함수는 함수의 위, 아래 어디서든지 호출실행가능
        //4. 익명함수는 함수의 아래에서만 호출실행가능

        //선언함수의 위, 아래 어디든지 위치에 관계없이 호출 가능
        func2();
        function func2(){  //선언적 함수
            let a = 400;
            let b = 500;
            return console.log(`선언적함수 리턴값 ${a+b}`);

        }
        func2();


        // 익명함수 변수 = function(){}
        //func1(); 호출 시 오류발생 반드시 함수 아래에서만 호출가능
        // func1(); 위에서 실행 시 오류!
        const func1 = function (x,y){ //매개변수
            let a = x;
            let b = y;
            return console.log(`익명함수 리턴값 ${a+b}`);
        }
        // 익명함수 : 실행은 반드시 함수 선언 아래에서만 가능하다.
        func1(); //아래에서 호출 가능 값이 없기 때문에 NaN출력
        func1(78,99); //전달인자 아규먼트 2개 적용되어 177 출력
        func1(100,299); //전달인자 2개
        func1(19,38); //전달인자 2개

        //function 키워드는 함수에 기본 키워드
        //화살표 함수 ES6 next ver 익명함수 아래에서만 호출가능
        // function fn(){

        // }

        // const fn=()=>{

        // }


        // //function fn1 = function(){

        // //}
        // const fn1=()=>{

        // }

        // // 1. 즉시표현함수식 화살표함수
        // (function(){

        // })();

        // // 2. 화살표 함수식 변경

        // (()=>{

        // })();

        // 화살표함수 실행
        const 함수1 = (pa) => { //매개변수
            console.log('함수1 내부 파라미터 값 출력', pa ); //리턴이 필요없이 함수 안에서 바로 결과 출력
        } 
        함수1( 9,99 ); //아규먼트(전달인자)

        //아래는 모두 리턴 결과

        const 함수2 = (pa) => {
            return pa +100;  //결과를 되돌려 받을 때 리턴이 필요하다.
        }
        console.log('함수 밖에서 결과 출력', 함수2(9,99));

        // 블록을 생략하고, 리턴문을 생략하여 한 줄로 표기 사용가능
        const 함수3 = (pa) => pa +100; //한 줄 코딩 화살표 함수는 즉시 리턴이 이루어진다.
        console.log('함수 밖에서 결과 출력', 함수3(9,99));
        
        //파라미터가 한 개인 경우는 소괄호를 생략할 수 있다.
        //단! 파라미터가 2개 이상인 경우는 반드시 소괄호로 감싸준다
        const 함수4 = pa => pa +100; //한 줄 코딩 화살표 함수는 즉시 리턴이 이루어진다.
        console.log('함수 밖에서 결과 출력', 함수4(9,99));

        //프로미스 비동기처리할 때는 반드시 화살표함수 사용

        //배열과 객체 그리고 함수
        const obj1 = {상품코드:'PRODUCT0001', 상품명: '딸기', 가격:'25000'}
        
  
        const 상품=(obj1)=>{
            
            console.log(obj1.상품코드);
            console.log(obj1.상품명);
            console.log(obj1.가격);
        }
        상품(obj1);

        const 상품2= (obj1) =>{
            const {상품코드, 상품명, 가격} = obj1;  //비구조화 > 구조분할할당
            console.log(상품코드);
            console.log(상품명);
            console.log(가격);
        }   
        상품2(obj1);

        const 상품3 =({상품코드, 상품명, 가격})=>{ //비구조화
                   
            console.log('매개변수에서 비구조화', 상품코드);
            console.log('매개변수에서 비구조화', 상품명);
            console.log('매개변수에서 비구조화', 가격);
        }
        상품3(obj1);

        // 화살표 함수 이용 배열값 검색
        const arr = ['사과','딸기','포도','메론'];

        // const result = 배열이름.map(function(){});
        const result = arr.map((item)=>item==='딸기'); //중괄호를 빼면 즉시 리턴
        console.log(result);
        // console.log(result.includes(true) ? 'ture':'false' );
        console.log(result.includes(true) ? '딸기 찾았다':'딸기 없다' );



        // 배열을 map함수를 이용 딸기를 검색 찾으면 true, 아니면 false를 반환
        // 비교연산자 이용 ===  <= >= > < !==같지 않다 논리값 true 또는 false
        // result[false, true, false, false];
        // 배열 안에 특정한 글자가 포함된 거 비교


    </script>
    
</body>
</html>